# Production CD Pipeline - ECR & Argo CD
# Triggers on push to main branch
# Builds, pushes to ECR, updates production values, and syncs Argo CD

name: Main ECR CD

on:
  push:
    branches: [main]

# Prevent concurrent deployments on the same branch
concurrency:
  group: main-cd
  cancel-in-progress: true

# Minimal permissions by default
permissions:
  contents: write
  id-token: write  # Required for AWS OIDC
  pull-requests: write

jobs:
  # Job 1: Prepare metadata
  meta:
    name: Prepare metadata
    runs-on: ubuntu-latest
    outputs:
      sha7: ${{ steps.compute.outputs.sha7 }}
      backend_repo_ecr: ${{ steps.repos.outputs.backend_repo_ecr }}
      frontend_repo_ecr: ${{ steps.repos.outputs.frontend_repo_ecr }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Compute short SHA
        id: compute
        run: |
          echo "sha7=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
      
      - name: Set ECR repository names
        id: repos
        run: |
          echo "backend_repo_ecr=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/prod-backend" >> $GITHUB_OUTPUT
          echo "frontend_repo_ecr=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/prod-frontend" >> $GITHUB_OUTPUT

  # Job 2: Authenticate with AWS
  aws-auth:
    name: AWS Authentication
    runs-on: ubuntu-latest
    needs: meta
    outputs:
      registry: ${{ steps.login-ecr.outputs.registry }}
    steps:
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-MainECRCD-${{ github.run_id }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

  # Job 3: Ensure ECR repositories exist
  ensure-ecr-repos:
    name: Ensure ECR repositories
    runs-on: ubuntu-latest
    needs: aws-auth
    steps:
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-EnsureECR-${{ github.run_id }}
      
      - name: Ensure prod-backend repository exists
        shell: bash
        run: |
          # Check if repository exists, create if it doesn't
          aws ecr describe-repositories --repository-names prod-backend --region ${{ secrets.AWS_REGION }} 2>/dev/null || \
          aws ecr create-repository \
            --repository-name prod-backend \
            --region ${{ secrets.AWS_REGION }} \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256
      
      - name: Ensure prod-frontend repository exists
        shell: bash
        run: |
          # Check if repository exists, create if it doesn't
          aws ecr describe-repositories --repository-names prod-frontend --region ${{ secrets.AWS_REGION }} 2>/dev/null || \
          aws ecr create-repository \
            --repository-name prod-frontend \
            --region ${{ secrets.AWS_REGION }} \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256

  # Job 4: Build and push to ECR
  build-and-push-ecr:
    name: Build & Push to ECR
    runs-on: ubuntu-latest
    needs: [meta, aws-auth, ensure-ecr-repos]
    outputs:
      backend_tag: ${{ needs.meta.outputs.sha7 }}
      frontend_tag: ${{ needs.meta.outputs.sha7 }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-BuildPush-${{ github.run_id }}
      
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2
      
      # Build and push backend
      - name: Build and push backend to ECR
        uses: docker/build-push-action@v6
        with:
          context: ./Backend
          push: true
          tags: |
            ${{ needs.meta.outputs.backend_repo_ecr }}:latest
            ${{ needs.meta.outputs.backend_repo_ecr }}:${{ needs.meta.outputs.sha7 }}
          platforms: linux/amd64,linux/arm64
      
      # Build and push frontend
      - name: Build and push frontend to ECR
        uses: docker/build-push-action@v6
        with:
          context: ./Frontend
          push: true
          tags: |
            ${{ needs.meta.outputs.frontend_repo_ecr }}:latest
            ${{ needs.meta.outputs.frontend_repo_ecr }}:${{ needs.meta.outputs.sha7 }}
          platforms: linux/amd64,linux/arm64

  # Job 5: Update Helm values for production environment
  update-values-prod:
    name: Update production values
    runs-on: ubuntu-latest
    needs: [meta, build-and-push-ecr]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_TOKEN }}
      
      # Check if manifests are in another repo
      - name: Checkout manifests repo (if different)
        if: ${{ secrets.MANIFESTS_REPO != '' }}
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.MANIFESTS_REPO }}
          ref: ${{ secrets.MANIFESTS_REPO_BRANCH || 'main' }}
          path: manifests
          token: ${{ secrets.GH_TOKEN }}
      
      - name: Install yq
        uses: mikefarah/yq@master
      
      # Update values in same repo
      - name: Update values in same repo
        if: ${{ secrets.MANIFESTS_REPO == '' }}
        run: |
          # Update backend values
          if [ -n "${{ secrets.PROD_VALUES_FILE_BACKEND }}" ]; then
            export REPO="${{ needs.meta.outputs.backend_repo_ecr }}"
            export TAG="${{ needs.meta.outputs.sha7 }}"
            yq -i '.image.repository = env(REPO) | .image.tag = env(TAG)' ${{ secrets.PROD_VALUES_FILE_BACKEND }}
          fi
          
          # Update frontend values
          if [ -n "${{ secrets.PROD_VALUES_FILE_FRONTEND }}" ]; then
            export REPO="${{ needs.meta.outputs.frontend_repo_ecr }}"
            export TAG="${{ needs.meta.outputs.sha7 }}"
            yq -i '.image.repository = env(REPO) | .image.tag = env(TAG)' ${{ secrets.PROD_VALUES_FILE_FRONTEND }}
          fi
          
          # Commit and push
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "chore(prod): update images to ${{ needs.meta.outputs.sha7 }}"
          git push origin main
      
      # Update values in different repo
      - name: Update values in different repo
        if: ${{ secrets.MANIFESTS_REPO != '' }}
        working-directory: manifests
        run: |
          # Create and checkout branch
          BRANCH_NAME="auto/prod-image-bump-${{ needs.meta.outputs.sha7 }}"
          git checkout -b $BRANCH_NAME
          
          # Update backend values
          if [ -n "${{ secrets.PROD_VALUES_FILE_BACKEND }}" ]; then
            export REPO="${{ needs.meta.outputs.backend_repo_ecr }}"
            export TAG="${{ needs.meta.outputs.sha7 }}"
            yq -i '.image.repository = env(REPO) | .image.tag = env(TAG)' ${{ secrets.PROD_VALUES_FILE_BACKEND }}
          fi
          
          # Update frontend values
          if [ -n "${{ secrets.PROD_VALUES_FILE_FRONTEND }}" ]; then
            export REPO="${{ needs.meta.outputs.frontend_repo_ecr }}"
            export TAG="${{ needs.meta.outputs.sha7 }}"
            yq -i '.image.repository = env(REPO) | .image.tag = env(TAG)' ${{ secrets.PROD_VALUES_FILE_FRONTEND }}
          fi
          
          # Commit and push
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "chore(prod): bump images to ${{ needs.meta.outputs.sha7 }}"
          git push origin $BRANCH_NAME
          
          # Create PR
          gh pr create \
            --title "chore(prod): bump images to ${{ needs.meta.outputs.sha7 }}" \
            --body "## Production Image Updates
            
            ### Backend
            - Repository: \`${{ needs.meta.outputs.backend_repo_ecr }}\`
            - Old Tag: \`latest\`
            - New Tag: \`${{ needs.meta.outputs.sha7 }}\`
            
            ### Frontend
            - Repository: \`${{ needs.meta.outputs.frontend_repo_ecr }}\`
            - Old Tag: \`latest\`
            - New Tag: \`${{ needs.meta.outputs.sha7 }}\`
            
            ### Deployment
            - AWS Account: \`${{ secrets.AWS_ACCOUNT_ID }}\`
            - Region: \`${{ secrets.AWS_REGION }}\`
            - ECR Repositories: \`prod-backend\`, \`prod-frontend\`" \
            --base ${{ secrets.MANIFESTS_REPO_BRANCH || 'main' }} \
            --head $BRANCH_NAME
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}

  # Job 6: Notify Argo CD for production apps
  notify-argocd-prod:
    name: Notify Argo CD Production
    runs-on: ubuntu-latest
    needs: update-values-prod
    if: ${{ secrets.ARGOCD_SERVER != '' && secrets.ARGOCD_AUTH_TOKEN != '' }}
    steps:
      - name: Refresh and sync Argo CD apps
        shell: bash
        run: |
          # Set curl options based on ARGOCD_INSECURE
          CURL_OPTS=""
          if [ "${{ secrets.ARGOCD_INSECURE }}" == "true" ]; then
            CURL_OPTS="-k"
          fi
          
          # Process each app in ARGOCD_PROD_APPS
          IFS=',' read -ra APPS <<< "${{ secrets.ARGOCD_PROD_APPS }}"
          for app in "${APPS[@]}"; do
            app=$(echo "$app" | xargs) # Trim whitespace
            echo "Processing production app: $app"
            
            # Refresh the app
            echo "Refreshing app: $app"
            curl $CURL_OPTS -X POST \
              -H "Authorization: Bearer ${{ secrets.ARGOCD_AUTH_TOKEN }}" \
              -H "Content-Type: application/json" \
              "https://${{ secrets.ARGOCD_SERVER }}/api/v1/applications/${app}/resource-tree?refresh=true"
            
            # Sync the app
            echo "Syncing app: $app"
            curl $CURL_OPTS -X POST \
              -H "Authorization: Bearer ${{ secrets.ARGOCD_AUTH_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d '{"prune": true, "dryRun": false, "strategy": {"hook": {"force": false}}}' \
              "https://${{ secrets.ARGOCD_SERVER }}/api/v1/applications/${app}/sync"
            
            echo "Completed processing for production app: $app"
          done
      
      - name: Comment on commit
        if: success()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_TOKEN || github.token }}
          script: |
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `âœ… **Production deployment initiated** for commit \`${context.sha.substring(0, 7)}\`\n\nImages pushed to ECR and Argo CD apps synced.`
            });
